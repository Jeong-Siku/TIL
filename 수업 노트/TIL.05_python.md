# Python

> 2023.03.16 (목)

## 함수

- type()

## 거듭제곱

- 2\*\*(1/2)
  - 지수는 정수 외에 다른 것도 사용 가능
- 300000=3\*10\*\*5

## 나머지

- / , // , %

## 과학적 표기법

- 10\*\*3=1e3
  - 항상 en 앞에 숫자가 있어야한다.
  - n은 양수,음수,0도 가능

## 진수 표현과 변환

- 0b0002
  - bin(17)
- 0o21
  - oct(17)
- 0x11
  - hex(17)
    - bin,oct,hex 출력값은 `문자열`이다.

## 논리 연산 및 비교 연산

- 논리연산 = 불린연산 , 참&거짓
- and, or, not
- == , != , > , < , <= , >=

# 변수와 자료형

## 변수

- 변수명 : 문자, 숫자, \_
- 숫자로 시작 불가
- 대소문자 구분
- 공백 포함 불가
- 특수문자 불가
- 예약어는 이용 불가
- `상수`

## 문자열

> 문자의 나열

- '' , ""
- str
- ''' '''', """ """
- 아스키코드 → 유니코드
- +는 `연결`, \*는 `반복`
- f-string

## 리스트

- []
- 순서대로
- 타입 혼합 가능
- 인덱스 가능
  - 변수명[n]
  - 있으면 갱신
- +는 `연결`, \*는 `반복`
- 슬라이싱가능
  - [::]
  - 새로만들기
- 삭제
  - `del 리스트[i]`
- 존재 여부 확인
  - `항목 in 리스트` → True or False

#### 리스트 메소드

- 변수명.메소드이름()
  - append('')
  - insert(1,'')
    - 해당 위치에 삽입
  - extend('','')
    - 여러개의 항목 추가
  - remove('')
  - pop()
  - index('')
  - count('')
  - sort()
  - reverse()

## 튜플

> 변경불가

- ()
- `,`로 생성 가능. 중요
- index , count 가능

## 세트

> 집합, 순서가 없고 `중복불가`하다. 교집합, 합집합, 차집합을 구하는 메서드 사용 가능.

- {}
- 집합메소드
  - A.intersection(B) : 교집합
    - A&B
  - A.unicon(B) : 합집합
    - A|B
  - A.difference(B) : 차집합
    - A-B

### 리스트, 튜플, 세트간 타입변환

- tuple()
- set()
- list()

## 딕셔너리

> 키와 값이 쌍으로 구성된다. 인덱스 대신에 키를 통해 값을 다룬다.

- {key1:value1,key2:value2....}
- 변수명[키]
- `데이터`에는 숫자나 문자열 , `값`에는 문자열,리스트,튜플,딕셔너리,숫자 입력 가능
- 데이터 추가 : `dict_variable[key]=value`
- 데이터 변경 : `dict_variable[key]=value`
- 데이터 삭제 : `del dict_variable[key]`

### 딕셔너리 메소드

- dict_data.메소드()
  - keys()
    - 리스트형태로
  - values()
    - 리스트형태로
  - items()
    - [튜플형태로]
  - update(dict_data2)
  - clear()

# 제어문

> 2023.03.18 (토)

## 01. 조건에 따라 분기하는 `if` 문

> 조건문은 `:`와 `들여쓰기` 중요

if <조건문>:  
<코드블록>

elif <조건문>:  
<코드블록>

else:  
<코드블록>

- 중첩조건문 가능
- pass : <코드블록>에 지정하여 if문의 전체적인 구조를 먼저 잡을 때 사용

## 02. 지정된 범위만큼 반복하는 for 문

> 반복문

- for <반복 변수> in <반복범위>:  
  <코드블록>

- 반복범위 지정

  - 리스트 이용
  - range() 함수 이용
    - 리스트로 사용하기 위해선 list()필요

- 반복 변수는 여러 개 입력 가능
- 반복범위는 하나 가능

- 중첩 for 문

- 여러개의 리스트 다루기

  - len()
  - 인덱스[] 다루기
  - zip(ls1,ls2) : 길이가 같은 리스트를 하나로 묶어준다. 동일한 인덱스의 값끼리 튜플로 묶어준다.

- object is not subscriptable : () 대신에 []를 사용할 시 나오는 오류문, list()화가 필요할 때 나올수도?
- object is not collable : [] 대신에 ()를 사용할 시 나오는 오류문

## 03. 조건에 따라 반복하는 while문

while <조건문>:  
<코드블록>

- 값들의 `초기화` 작업 생각하기
- while내에 코드블록은 브레이크문 뒤가 아니면 모두 작업된다.

- 무한반복 while문
  - <조건문>에 True 사용

## 04. 반복문을 제어하는 break와 continue

- break : 해당 반복문을 중지한다
- continue : 해당 루프를 벗어난다.

## 05. 간단하게 반복하는 for문

> 리스트, 세트, 딕셔너리 내에서 실행하는 구문.

- 리스트 컴프리헨션(내포)
- 세트 컴프리헨션
- 딕셔너리 컴프리헨션

- 리스트 컴프리헨션의 기본 구조
  - [<반복 실행문> for <반복변수> in <반복범위>]
    - 기존의 <코드블록>을 : 없이 바로 가져온다.
    - 리스트 초기화 작업이 필요없다.
- 조건문을 포함한 리스트 컴프리헨션
  - [<반복 실행문> for <반복변수> in <반복범위> if <조건문>]

# 입력과 출력

## 01. 화면 출력

> print(). 출력형식을 지정하지 않는 기본 출력 방법과 다양한형식으로 출력할 수 있는 지정 출력 방법이 있다.

- 기본출력

  - `' '` `,` `" "`
  - ,는 기본적으로 공백
  - sep() : 공백을 다른 문자열로 교체
  - +는 연결
  - 변수의 값 출력
  - \n : 개행
  - end() : 라인 끝의 값을 지정

- 형식 지정 출력
  - print("%type" %data)
  - print("%type %type" %(data1, data2)
  - %s:문자열 , %d or %i:정수 , %f:실수

> a is not defined : ''으로 문자열로 정의할 것

- 형식 지정 문자열에서 출력 위치 지정

  - 'string.format()'
  - print("{0},{1},{2},,,,{n}".format(data0,data_1,data_2,,,data_n))

- 형식 지정 문자열에서 숫자 출력 형식 지정
  - {N:'출력 형식'}
  - d : 정수
  - f : 실수
    - {N:.3f}
    - {N:.1%}

## 02. 키보드 입력

- data = input("문자열")
- input() : 문자열로 출력
  - int() 등의 작업 필요

## 03. 파일 읽고 쓰기

- 파일열기

  - f = open('file_name','mode')
    - mode : r, w, a,

- 파일쓰기

  - f = open('file_name','w')  
    f.writes("")  
    f.close
  - !type 파일이름 ,!cat 파일이름 : 내용을 화면에 출력

- 파일 읽기
  - f = open('file_name','r')
    file_text = f.read()
    f.close()

## 04. 반복문을 이용해 파일 읽고 쓰기

- write 함수는 자동으로 개행이 되지않는다. 주의
- 파일에서 문자열 한줄 씩 쓰기

  - for 변수 in range 함수 사용

- 파일에서 문자열 한줄 씩 읽기

  - 한줄씩 읽기
    - readline() , readlines() 사용
    - 자동으로 \n이 포함
    - 빈문자열은 False로도 읽는다.
    - readlines()는 리스트로 출력

- with 문을 활용해 파일 읽고 쓰기
  - close()를 수행할 필요가 없다
  - with open("file_name",'mode') as f :
    <코드블록>

# 함수

> 특정 기능을 수행하는 코드의 묶음

## 01. 함수정의와 호출

> 수학함수와 달리 인자와 반환값이 없을 수 도 있다. 함수의 수정은 함수를 호출하는 모든 코드의 값에 적용. 즉, 수정이 용이하다

- 함수의 기본 구조
  - def 함수명([인자1,인자2,,,인자n]):  
     <코드블록>  
    [return <반환값>]
  - 대괄호는 생략가능
    - 인자도 반환값도 없는 함수
    - 인자는 있으나 반환 값이 없는 함수 : 호출
    - 인자도 있고 반환 값도 있는 함수
      - 인자로 리스트, 세트, 튜플, 딕셔너리 사용 가능

## 02. 변수의 유효 범위

- 지역변수 : 함수 영역안에서만 동작하는 변수
- 전역변수 : 코드 내 어디서나 사용 가능

- 지역변수와 전역변수가 같을 경우, 지역변수의 값을 변경하고 싶다면 `global 전역변수명`을 사용한다.

## 03. 람다(lambda) 함수

> 한 줄로 함수를 표현하는 함수 . 인자를 전달하면 코드를 수행한 후 결과를 바로 반환한다.

- (lambda <인자> : <인자 활용 수행 코드>) (인자)

- ex) lambda_function = lambda <인자> : <인자 활용 수행코드>  
   lambda_function(<인자>)

  - 기본적으로는 람다함수를 ()로 감싸지만 람다함수를 변수에 할당할 때는 소괄호로 감싸지 않아도 된다.

- lambda x,y,z : 2*x + 2*y+3\*z

## 04. 유용한 내장 함수

- 형 변환 함수

  - int()
  - float()
  - str()
  - list()
  - tuple()
  - set()

  </br>

- bool 함수
  - 숫자를 인자로 bool 함수 호출
    - bool(0)을 제외하면 다 True
  - 문자열을 인자로 bool 함수 호출
    - bool('')과 None는 False 공백은 True
  - 리스트, 튜플, 세트를 인자로 bool 함수 호출
    - [],(),{} : 비어있다
  - if 등 조건문에 활용 가능

</br>

- 최소값과 최댓값을 구하는 함수
  - min(), max()
  - 숫자뿐만 아니라 문자열도 가능
  - 튜플과 세트

</br>

- 절댓값과 전체 합을 구하는 함수

  - abs()
  - sum()

- 항목의 개수
  - len()

# 객채와 클래스

> object , class

## 01. 클래스 선언과 객체 생성

- 객체 : `속성(값`과 행위(`메소드`)로 구성된 대상.
  - 클래스의 인스턴스
- 클래스 : 객체의 공통된 속성과 행위를 변수와 함수로 정의한 것. 객체를 만들기 위한 기본틀
  - 클래스명은 대문자로 시작
  - 클래스에서 정의한 함수의 첫번째 인자는 `self`
    - self는 자신을 참조하는데 이용

```bash
메소드 : 클래스에서 정의한 함수를 객체를 생성한 후에 이용할 때는 메소드라고 한다. 하지만 함수와 메소드 둘 다 클래스에서 정의한 함수를 뜻한다

클래스 내의 함수는 행위를 지정한다. 속성과 별도이다.
```

- 객체 생성 및 활용

  - 클래스를 선언
    - class 클래스명():
  - 클래스의 `인스턴스`인 객체를 생성
    - 객체명 = 클래스명()
  - `속성` 설정
    - 객체명.변수명 = 속성값
  - 객체의 메소드 호출
    - 객체명.메소드명([인자1,인자2,...,인자n])

- 객체 초기화
  - \_\_init\_\_(self,속성명1,속성명2...) : `초기화 함수`로서 객체(클래스의 인스턴스)를 생성하는 것과 동시에 속성값을 지정할 수 있다.
  - 객체명 = 클래스명(인자1,인자2...)

## 02. 클래스를 구성하는 변수와 함수

- 클래스에서 사용하는 변수

  - 클래스 변수
    - '변수명 = 데이터'
    - '클래스명.변수명'
    - 각 객체에 공통적으로 사용
  - 인스턴스 변수
    - 'self.변수명=데이터'
    - '객체명.변수명'
    - 각 객체에서 개별적으로 관리
  - 클래스 변수와 인스턴스 변수는 이름이 동일해도 별개로 동작한다.

- 클래스에서 사용하는 함수
  - 인스턴스 메소드
    - 각 객체에서 개별적으로 동작하는 함수
    - self를 통해 인스턴스 변수를 만들고 사용
    - 첫인자로 self
  - 정적 메소드
    - 클래스나 클래스의 인스턴스와는 독립적으로 동작하는 함수
    - @staticmethod
    - 객체생성없이, 클래스명.메소드명([인자1,인자2,,,])
    - self 인자없이 사용한다.
  - 클래스 메소드
    - 클래스변수를 사용하기 위한 함수
    - 클래스 전체에서 관리해야할 기능이 있을 때 주로 이용
    - @classmethod
    - 객체생성없이, 클래스명,메소드명(cls[인자1,인자2,,,])

> 2023.03.21 (화)

## 03. 객체와 클래스를 사용하는 이유

## 04. 클래스 상속

- `확장`, 부모클래스의 기능에 추가
- class 자식 클래스 이름(부모 클래스 이름)
  - 오버라이딩으로 인해 부모클래스의 함수를 호출하려면
    - 부모클래스이름.함수명()
    - super().함수명()
    - \_\_init\_\_에서 처리한다.
  - 상속받은 클래스에서 생성한 객체는 부모의 함수 사용 가능

# 문자열과 텍스트 파일 데이터 다루기

## 01. 문자열 다루기

### 1. 문자열 분리하기

- .split([sep])
  - 문자열을 항목으로 담은 리스트를 반환
  - 인자없이 사용시 `공백과 개행문자`를 없애고 분리된 문자열 반환
  - .split([sep,]maxsplit=n)
    - 앞에서부터 원하는 횟수만큼만 문자열을 분리

### 2. 필요없는 문자열 삭제하기

- str.strip([chars])
  - 앞과 뒤에서 시작해서 지정한 문자외의 다른 문자를 만날 때까지 `지정한 문자를 모두 삭제`한 문자열을 반환
  - chars는 순서상관없이 다수 지정가능
  - 다만 가운데에 글자는 삭제 불가
  - .lstrip
  - .rstrip

### 3. 문자열 연결하기

- \+ 연산자
- str.join(seq)

### 4. 문자열 찾기

- str.find(search_str, start, end)
- str.count(search_str, start, end)
- str.startswith(prefix, start, end) : bool
- str.endswith(suffix, start, end) : bool

### 5. 문자열 바꾸기

- str.replace(old, new\[,count])

### 6.문자열의 구성 확인하기

bool

- str.isalpha()
- str.isdigit()
- str.isalnum()
- str.isspace()
- str.isupper()
- str.islower()

### 7. 대소문자로 변경하기

- str.lower()
- str.upper()

## 2. 텍스트 파일의 데이터를 읽고 처리하기
